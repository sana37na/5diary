{"ast":null,"code":"import _toConsumableArray from \"/Users/sanami/Desktop/react/webgl/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _createForOfIteratorHelper from \"/Users/sanami/Desktop/react/webgl/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _defineProperty from \"/Users/sanami/Desktop/react/webgl/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"/Users/sanami/Desktop/react/webgl/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/sanami/Desktop/react/webgl/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Vector3, BufferAttribute, Box3 } from 'three';\nimport { CENTER } from './Constants.js';\nimport { BYTES_PER_NODE, IS_LEAFNODE_FLAG, buildPackedTree } from './buildFunctions.js';\nimport { OrientedBox } from './Utils/OrientedBox.js';\nimport { SeparatingAxisTriangle } from './Utils/SeparatingAxisTriangle.js';\nimport { setTriangle } from './Utils/TriangleUtils.js';\nimport { raycast as _raycast, raycastFirst as _raycastFirst, shapecast as _shapecast, intersectsGeometry as _intersectsGeometry, setBuffer, clearBuffer } from './castFunctions.js';\nimport { arrayToBox, iterateOverTriangles } from './Utils/BufferNodeUtils.js';\nvar SKIP_GENERATION = Symbol('skip tree generation');\nvar obb = new OrientedBox();\nvar obb2 = new OrientedBox();\nvar temp = new Vector3();\nvar temp1 = new Vector3();\nvar temp2 = new Vector3();\nvar tempBox = new Box3();\nvar triangle = new SeparatingAxisTriangle();\nvar triangle2 = new SeparatingAxisTriangle();\n\nvar MeshBVH = /*#__PURE__*/function () {\n  function MeshBVH(geometry) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, MeshBVH);\n\n    if (!geometry.isBufferGeometry) {\n      throw new Error('MeshBVH: Only BufferGeometries are supported.');\n    } else if (geometry.index && geometry.index.isInterleavedBufferAttribute) {\n      throw new Error('MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.');\n    } // default options\n\n\n    options = Object.assign(_defineProperty({\n      strategy: CENTER,\n      maxDepth: 40,\n      maxLeafTris: 10,\n      verbose: true,\n      setBoundingBox: true\n    }, SKIP_GENERATION, false), options);\n    options.strategy = Math.max(0, Math.min(2, options.strategy));\n    this._roots = null;\n\n    if (!options[SKIP_GENERATION]) {\n      this._roots = buildPackedTree(geometry, options);\n\n      if (!geometry.boundingBox && options.setBoundingBox) {\n        geometry.boundingBox = this.getBoundingBox(new Box3());\n      }\n    } // retain references to the geometry so we can use them it without having to\n    // take a geometry reference in every function.\n\n\n    this.geometry = geometry;\n  }\n\n  _createClass(MeshBVH, [{\n    key: \"refit\",\n    value: function refit() {\n      var nodeIndices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var terminationIndices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (nodeIndices && Array.isArray(nodeIndices)) {\n        nodeIndices = new Set(nodeIndices);\n      }\n\n      if (terminationIndices && Array.isArray(terminationIndices)) {\n        terminationIndices = new Set(terminationIndices);\n      }\n\n      var geometry = this.geometry;\n      var indexArr = geometry.index.array;\n      var posAttr = geometry.attributes.position;\n      var posArr = posAttr.array; // support for an interleaved position buffer\n\n      var bufferOffset = posAttr.offset || 0;\n      var stride = 3;\n\n      if (posAttr.isInterleavedBufferAttribute) {\n        stride = posAttr.data.stride;\n      }\n\n      var buffer, uint32Array, uint16Array, float32Array;\n      var byteOffset = 0;\n      var roots = this._roots;\n\n      for (var i = 0, l = roots.length; i < l; i++) {\n        buffer = roots[i];\n        uint32Array = new Uint32Array(buffer);\n        uint16Array = new Uint16Array(buffer);\n        float32Array = new Float32Array(buffer);\n\n        _traverse(0, byteOffset);\n\n        byteOffset += buffer.byteLength;\n      }\n\n      function _traverse(node32Index, byteOffset) {\n        var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var node16Index = node32Index * 2;\n        var isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;\n\n        if (isLeaf) {\n          var offset = uint32Array[node32Index + 6];\n          var count = uint16Array[node16Index + 14];\n          var minx = Infinity;\n          var miny = Infinity;\n          var minz = Infinity;\n          var maxx = -Infinity;\n          var maxy = -Infinity;\n          var maxz = -Infinity;\n\n          for (var _i = 3 * offset, _l = 3 * (offset + count); _i < _l; _i++) {\n            var index = indexArr[_i] * stride + bufferOffset;\n            var x = posArr[index + 0];\n            var y = posArr[index + 1];\n            var z = posArr[index + 2];\n            if (x < minx) minx = x;\n            if (x > maxx) maxx = x;\n            if (y < miny) miny = y;\n            if (y > maxy) maxy = y;\n            if (z < minz) minz = z;\n            if (z > maxz) maxz = z;\n          }\n\n          if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {\n            float32Array[node32Index + 0] = minx;\n            float32Array[node32Index + 1] = miny;\n            float32Array[node32Index + 2] = minz;\n            float32Array[node32Index + 3] = maxx;\n            float32Array[node32Index + 4] = maxy;\n            float32Array[node32Index + 5] = maxz;\n            return true;\n          } else {\n            return false;\n          }\n        } else {\n          var left = node32Index + 8;\n          var right = uint32Array[node32Index + 6]; // the indentifying node indices provided by the shapecast function include offsets of all\n          // root buffers to guarantee they're unique between roots so offset left and right indices here.\n\n          var offsetLeft = left + byteOffset;\n          var offsetRight = right + byteOffset;\n          var leftChange = false;\n          var forceLeft = force || terminationIndices && terminationIndices.has(offsetLeft);\n          var traverseLeft = forceLeft || (nodeIndices ? nodeIndices.has(offsetLeft) : true);\n\n          if (traverseLeft) {\n            leftChange = _traverse(left, byteOffset, forceLeft);\n          }\n\n          var rightChange = false;\n          var forceRight = force || terminationIndices && terminationIndices.has(offsetRight);\n          var traverseRight = forceRight || (nodeIndices ? nodeIndices.has(offsetRight) : true);\n\n          if (traverseRight) {\n            rightChange = _traverse(right, byteOffset, forceRight);\n          }\n\n          var didChange = leftChange || rightChange;\n\n          if (didChange) {\n            for (var _i2 = 0; _i2 < 3; _i2++) {\n              var lefti = left + _i2;\n              var righti = right + _i2;\n              var minLeftValue = float32Array[lefti];\n              var maxLeftValue = float32Array[lefti + 3];\n              var minRightValue = float32Array[righti];\n              var maxRightValue = float32Array[righti + 3];\n              float32Array[node32Index + _i2] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n              float32Array[node32Index + _i2 + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n            }\n          }\n\n          return didChange;\n        }\n      }\n    }\n  }, {\n    key: \"traverse\",\n    value: function traverse(callback) {\n      var rootIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var buffer = this._roots[rootIndex];\n      var uint32Array = new Uint32Array(buffer);\n      var uint16Array = new Uint16Array(buffer);\n\n      _traverse(0);\n\n      function _traverse(node32Index) {\n        var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var node16Index = node32Index * 2;\n        var isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;\n\n        if (isLeaf) {\n          var offset = uint32Array[node32Index + 6];\n          var count = uint16Array[node16Index + 14];\n          callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), offset, count);\n        } else {\n          var left = node32Index + BYTES_PER_NODE / 4;\n          var right = uint32Array[node32Index + 6];\n          var splitAxis = uint32Array[node32Index + 7];\n          var stopTraversal = callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), splitAxis);\n\n          if (!stopTraversal) {\n            _traverse(left, depth + 1);\n\n            _traverse(right, depth + 1);\n          }\n        }\n      }\n    }\n    /* Core Cast Functions */\n\n  }, {\n    key: \"raycast\",\n    value: function raycast(mesh, raycaster, ray, intersects) {\n      var geometry = this.geometry;\n      var localIntersects = intersects ? [] : null;\n\n      var _iterator = _createForOfIteratorHelper(this._roots),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var root = _step.value;\n          setBuffer(root);\n\n          _raycast(0, mesh, geometry, raycaster, ray, localIntersects);\n\n          clearBuffer();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (intersects) {\n        for (var i = 0, l = localIntersects.length; i < l; i++) {\n          delete localIntersects[i].localPoint;\n        }\n\n        intersects.push.apply(intersects, _toConsumableArray(localIntersects));\n      }\n    }\n  }, {\n    key: \"raycastFirst\",\n    value: function raycastFirst(mesh, raycaster, ray) {\n      var geometry = this.geometry;\n      var closestResult = null;\n\n      var _iterator2 = _createForOfIteratorHelper(this._roots),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var root = _step2.value;\n          setBuffer(root);\n\n          var result = _raycastFirst(0, mesh, geometry, raycaster, ray);\n\n          clearBuffer();\n\n          if (result != null && (closestResult == null || result.distance < closestResult.distance)) {\n            closestResult = result;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      if (closestResult) {\n        delete closestResult.localPoint;\n      }\n\n      return closestResult;\n    }\n  }, {\n    key: \"intersectsGeometry\",\n    value: function intersectsGeometry(mesh, otherGeometry, geomToMesh) {\n      var geometry = this.geometry;\n      var result = false;\n\n      var _iterator3 = _createForOfIteratorHelper(this._roots),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var root = _step3.value;\n          setBuffer(root);\n          result = _intersectsGeometry(0, mesh, geometry, otherGeometry, geomToMesh);\n          clearBuffer();\n\n          if (result) {\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return result;\n    }\n  }, {\n    key: \"shapecast\",\n    value: function shapecast(mesh, callbacks, _intersectsTriangleFunc, _orderNodesFunc) {\n      var geometry = this.geometry;\n\n      if (callbacks instanceof Function) {\n        if (_intersectsTriangleFunc) {\n          // Support the previous function signature that provided three sequential index buffer\n          // indices here.\n          var originalTriangleFunc = _intersectsTriangleFunc;\n\n          _intersectsTriangleFunc = function _intersectsTriangleFunc(tri, index, contained, depth) {\n            var i3 = index * 3;\n            return originalTriangleFunc(tri, i3, i3 + 1, i3 + 2, contained, depth);\n          };\n        }\n\n        callbacks = {\n          boundsTraverseOrder: _orderNodesFunc,\n          intersectsBounds: callbacks,\n          intersectsTriangle: _intersectsTriangleFunc,\n          intersectsRange: null\n        };\n        console.warn('MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.');\n      }\n\n      var _callbacks = callbacks,\n          boundsTraverseOrder = _callbacks.boundsTraverseOrder,\n          intersectsBounds = _callbacks.intersectsBounds,\n          intersectsRange = _callbacks.intersectsRange,\n          intersectsTriangle = _callbacks.intersectsTriangle;\n\n      if (intersectsRange && intersectsTriangle) {\n        var originalIntersectsRange = intersectsRange;\n\n        intersectsRange = function intersectsRange(offset, count, contained, depth, nodeIndex) {\n          if (!originalIntersectsRange(offset, count, contained, depth, nodeIndex)) {\n            return iterateOverTriangles(offset, count, geometry, intersectsTriangle, contained, depth, triangle);\n          }\n\n          return true;\n        };\n      } else if (!intersectsRange) {\n        if (intersectsTriangle) {\n          intersectsRange = function intersectsRange(offset, count, contained, depth) {\n            return iterateOverTriangles(offset, count, geometry, intersectsTriangle, contained, depth, triangle);\n          };\n        } else {\n          intersectsRange = function intersectsRange(offset, count, contained) {\n            return contained;\n          };\n        }\n      }\n\n      var result = false;\n      var byteOffset = 0;\n\n      var _iterator4 = _createForOfIteratorHelper(this._roots),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var root = _step4.value;\n          setBuffer(root);\n          result = _shapecast(0, geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);\n          clearBuffer();\n\n          if (result) {\n            break;\n          }\n\n          byteOffset += root.byteLength;\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      return result;\n    }\n    /* Derived Cast Functions */\n\n  }, {\n    key: \"intersectsBox\",\n    value: function intersectsBox(mesh, box, boxToMesh) {\n      obb.set(box.min, box.max, boxToMesh);\n      obb.needsUpdate = true;\n      return this.shapecast(mesh, {\n        intersectsBounds: function intersectsBounds(box) {\n          return obb.intersectsBox(box);\n        },\n        intersectsTriangle: function intersectsTriangle(tri) {\n          return obb.intersectsTriangle(tri);\n        }\n      });\n    }\n  }, {\n    key: \"intersectsSphere\",\n    value: function intersectsSphere(mesh, sphere) {\n      return this.shapecast(mesh, {\n        intersectsBounds: function intersectsBounds(box) {\n          return sphere.intersectsBox(box);\n        },\n        intersectsTriangle: function intersectsTriangle(tri) {\n          return tri.intersectsSphere(sphere);\n        }\n      });\n    }\n  }, {\n    key: \"closestPointToGeometry\",\n    value: function closestPointToGeometry(mesh, otherGeometry, geometryToBvh) {\n      var target1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      var target2 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n      var minThreshold = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n      var maxThreshold = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : Infinity;\n\n      if (!otherGeometry.boundingBox) {\n        otherGeometry.computeBoundingBox();\n      }\n\n      obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n      obb.needsUpdate = true;\n      var geometry = this.geometry;\n      var pos = geometry.attributes.position;\n      var index = geometry.index;\n      var otherPos = otherGeometry.attributes.position;\n      var otherIndex = otherGeometry.index;\n      var tempTarget1 = null;\n      var tempTarget2 = null;\n\n      if (target1) {\n        tempTarget1 = temp1;\n      }\n\n      if (target2) {\n        tempTarget2 = temp2;\n      }\n\n      var closestDistance = Infinity;\n      obb2.matrix.copy(geometryToBvh).invert();\n      this.shapecast(mesh, {\n        boundsTraverseOrder: function boundsTraverseOrder(box) {\n          return obb.distanceToBox(box, Math.min(closestDistance, maxThreshold));\n        },\n        intersectsBounds: function intersectsBounds(box, isLeaf, score) {\n          if (score < closestDistance && score < maxThreshold) {\n            // if we know the triangles of this bounds will be intersected next then\n            // save the bounds to use during triangle checks.\n            if (isLeaf) {\n              obb2.min.copy(box.min);\n              obb2.max.copy(box.max);\n              obb2.needsUpdate = true;\n            }\n\n            return true;\n          }\n\n          return false;\n        },\n        intersectsRange: function intersectsRange(offset, count) {\n          if (otherGeometry.boundsTree) {\n            // if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n            // the closest bounds in the other geometry to check.\n            return otherGeometry.boundsTree.shapecast(null, {\n              boundsTraverseOrder: function boundsTraverseOrder(box) {\n                return obb2.distanceToBox(box, Math.min(closestDistance, maxThreshold));\n              },\n              intersectsBounds: function intersectsBounds(box, isLeaf, score) {\n                return score < closestDistance && score < maxThreshold;\n              },\n              intersectsRange: function intersectsRange(otherOffset, otherCount) {\n                for (var i2 = otherOffset * 3, l2 = (otherOffset + otherCount) * 3; i2 < l2; i2 += 3) {\n                  setTriangle(triangle2, i2, otherIndex, otherPos);\n                  triangle2.a.applyMatrix4(geometryToBvh);\n                  triangle2.b.applyMatrix4(geometryToBvh);\n                  triangle2.c.applyMatrix4(geometryToBvh);\n                  triangle2.needsUpdate = true;\n\n                  for (var i = offset * 3, l = (offset + count) * 3; i < l; i += 3) {\n                    setTriangle(triangle, i, index, pos);\n                    triangle.needsUpdate = true;\n                    var dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n\n                    if (dist < closestDistance) {\n                      if (target1) {\n                        target1.copy(tempTarget1);\n                      }\n\n                      if (target2) {\n                        target2.copy(tempTarget2);\n                      }\n\n                      closestDistance = dist;\n                    } // stop traversal if we find a point that's under the given threshold\n\n\n                    if (dist < minThreshold) {\n                      return true;\n                    }\n                  }\n                }\n              }\n            });\n          } else {\n            // If no bounds tree then we'll just check every triangle.\n            var triCount = otherIndex ? otherIndex.count : otherPos.count;\n\n            for (var i2 = 0, l2 = triCount; i2 < l2; i2 += 3) {\n              setTriangle(triangle2, i2, otherIndex, otherPos);\n              triangle2.a.applyMatrix4(geometryToBvh);\n              triangle2.b.applyMatrix4(geometryToBvh);\n              triangle2.c.applyMatrix4(geometryToBvh);\n              triangle2.needsUpdate = true;\n\n              for (var i = offset * 3, l = (offset + count) * 3; i < l; i += 3) {\n                setTriangle(triangle, i, index, pos);\n                triangle.needsUpdate = true;\n                var dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n\n                if (dist < closestDistance) {\n                  if (target1) {\n                    target1.copy(tempTarget1);\n                  }\n\n                  if (target2) {\n                    target2.copy(tempTarget2);\n                  }\n\n                  closestDistance = dist;\n                } // stop traversal if we find a point that's under the given threshold\n\n\n                if (dist < minThreshold) {\n                  return true;\n                }\n              }\n            }\n          }\n        }\n      });\n      return closestDistance;\n    }\n  }, {\n    key: \"distanceToGeometry\",\n    value: function distanceToGeometry(mesh, geom, matrix, minThreshold, maxThreshold) {\n      return this.closestPointToGeometry(mesh, geom, matrix, null, null, minThreshold, maxThreshold);\n    }\n  }, {\n    key: \"closestPointToPoint\",\n    value: function closestPointToPoint(mesh, point, target) {\n      var minThreshold = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var maxThreshold = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Infinity;\n      // early out if under minThreshold\n      // skip checking if over maxThreshold\n      // set minThreshold = maxThreshold to quickly check if a point is within a threshold\n      // returns Infinity if no value found\n      var minThresholdSq = minThreshold * minThreshold;\n      var maxThresholdSq = maxThreshold * maxThreshold;\n      var closestDistanceSq = Infinity;\n      this.shapecast(mesh, {\n        boundsTraverseOrder: function boundsTraverseOrder(box) {\n          temp.copy(point).clamp(box.min, box.max);\n          return temp.distanceToSquared(point);\n        },\n        intersectsBounds: function intersectsBounds(box, isLeaf, score) {\n          return score < closestDistanceSq && score < maxThresholdSq;\n        },\n        intersectsTriangle: function intersectsTriangle(tri) {\n          tri.closestPointToPoint(point, temp);\n          var distSq = point.distanceToSquared(temp);\n\n          if (distSq < closestDistanceSq) {\n            if (target) {\n              target.copy(temp);\n            }\n\n            closestDistanceSq = distSq;\n          }\n\n          if (distSq < minThresholdSq) {\n            return true;\n          } else {\n            return false;\n          }\n        }\n      });\n      return Math.sqrt(closestDistanceSq);\n    }\n  }, {\n    key: \"distanceToPoint\",\n    value: function distanceToPoint(mesh, point, minThreshold, maxThreshold) {\n      return this.closestPointToPoint(mesh, point, null, minThreshold, maxThreshold);\n    }\n  }, {\n    key: \"getBoundingBox\",\n    value: function getBoundingBox(target) {\n      target.makeEmpty();\n      var roots = this._roots;\n      roots.forEach(function (buffer) {\n        arrayToBox(0, new Float32Array(buffer), tempBox);\n        target.union(tempBox);\n      });\n      return target;\n    }\n  }], [{\n    key: \"serialize\",\n    value: function serialize(bvh, geometry) {\n      var copyIndexBuffer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var rootData = bvh._roots;\n      var indexAttribute = geometry.getIndex();\n      var result = {\n        roots: rootData,\n        index: copyIndexBuffer ? indexAttribute.array.slice() : indexAttribute.array\n      };\n      return result;\n    }\n  }, {\n    key: \"deserialize\",\n    value: function deserialize(data, geometry) {\n      var setIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var index = data.index,\n          roots = data.roots;\n      var bvh = new MeshBVH(geometry, _defineProperty({}, SKIP_GENERATION, true));\n      bvh._roots = roots;\n\n      if (setIndex) {\n        var indexAttribute = geometry.getIndex();\n\n        if (indexAttribute === null) {\n          var newIndex = new BufferAttribute(data.index, 1, false);\n          geometry.setIndex(newIndex);\n        } else if (indexAttribute.array !== index) {\n          indexAttribute.array.set(index);\n          indexAttribute.needsUpdate = true;\n        }\n      }\n\n      return bvh;\n    }\n  }]);\n\n  return MeshBVH;\n}();\n\nexport { MeshBVH as default };","map":{"version":3,"sources":["/Users/sanami/Desktop/react/webgl/node_modules/three-mesh-bvh/src/MeshBVH.js"],"names":["Vector3","BufferAttribute","Box3","CENTER","BYTES_PER_NODE","IS_LEAFNODE_FLAG","buildPackedTree","OrientedBox","SeparatingAxisTriangle","setTriangle","raycast","raycastFirst","shapecast","intersectsGeometry","setBuffer","clearBuffer","arrayToBox","iterateOverTriangles","SKIP_GENERATION","Symbol","obb","obb2","temp","temp1","temp2","tempBox","triangle","triangle2","MeshBVH","geometry","options","isBufferGeometry","Error","index","isInterleavedBufferAttribute","Object","assign","strategy","maxDepth","maxLeafTris","verbose","setBoundingBox","Math","max","min","_roots","boundingBox","getBoundingBox","nodeIndices","terminationIndices","Array","isArray","Set","indexArr","array","posAttr","attributes","position","posArr","bufferOffset","offset","stride","data","buffer","uint32Array","uint16Array","float32Array","byteOffset","roots","i","l","length","Uint32Array","Uint16Array","Float32Array","_traverse","byteLength","node32Index","force","node16Index","isLeaf","count","minx","Infinity","miny","minz","maxx","maxy","maxz","x","y","z","left","right","offsetLeft","offsetRight","leftChange","forceLeft","has","traverseLeft","rightChange","forceRight","traverseRight","didChange","lefti","righti","minLeftValue","maxLeftValue","minRightValue","maxRightValue","callback","rootIndex","depth","splitAxis","stopTraversal","mesh","raycaster","ray","intersects","localIntersects","root","localPoint","push","closestResult","result","distance","otherGeometry","geomToMesh","callbacks","_intersectsTriangleFunc","_orderNodesFunc","Function","originalTriangleFunc","tri","contained","i3","boundsTraverseOrder","intersectsBounds","intersectsTriangle","intersectsRange","console","warn","originalIntersectsRange","nodeIndex","box","boxToMesh","set","needsUpdate","intersectsBox","sphere","intersectsSphere","geometryToBvh","target1","target2","minThreshold","maxThreshold","computeBoundingBox","pos","otherPos","otherIndex","tempTarget1","tempTarget2","closestDistance","matrix","copy","invert","distanceToBox","score","boundsTree","otherOffset","otherCount","i2","l2","a","applyMatrix4","b","c","dist","distanceToTriangle","triCount","geom","closestPointToGeometry","point","target","minThresholdSq","maxThresholdSq","closestDistanceSq","clamp","distanceToSquared","closestPointToPoint","distSq","sqrt","makeEmpty","forEach","union","bvh","copyIndexBuffer","rootData","indexAttribute","getIndex","slice","setIndex","newIndex"],"mappings":"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","sourcesContent":["import { Vector3, BufferAttribute, Box3 } from 'three';\r\nimport { CENTER } from './Constants.js';\r\nimport { BYTES_PER_NODE, IS_LEAFNODE_FLAG, buildPackedTree } from './buildFunctions.js';\r\nimport { OrientedBox } from './Utils/OrientedBox.js';\r\nimport { SeparatingAxisTriangle } from './Utils/SeparatingAxisTriangle.js';\r\nimport { setTriangle } from './Utils/TriangleUtils.js';\r\nimport {\r\n\traycast,\r\n\traycastFirst,\r\n\tshapecast,\r\n\tintersectsGeometry,\r\n\tsetBuffer,\r\n\tclearBuffer,\r\n} from './castFunctions.js';\r\nimport { arrayToBox, iterateOverTriangles } from './Utils/BufferNodeUtils.js';\r\n\r\nconst SKIP_GENERATION = Symbol( 'skip tree generation' );\r\n\r\nconst obb = new OrientedBox();\r\nconst obb2 = new OrientedBox();\r\nconst temp = new Vector3();\r\nconst temp1 = new Vector3();\r\nconst temp2 = new Vector3();\r\nconst tempBox = new Box3();\r\nconst triangle = new SeparatingAxisTriangle();\r\nconst triangle2 = new SeparatingAxisTriangle();\r\n\r\nexport default class MeshBVH {\r\n\r\n\tstatic serialize( bvh, geometry, copyIndexBuffer = true ) {\r\n\r\n\t\tconst rootData = bvh._roots;\r\n\t\tconst indexAttribute = geometry.getIndex();\r\n\t\tconst result = {\r\n\t\t\troots: rootData,\r\n\t\t\tindex: copyIndexBuffer ? indexAttribute.array.slice() : indexAttribute.array,\r\n\t\t};\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tstatic deserialize( data, geometry, setIndex = true ) {\r\n\r\n\t\tconst { index, roots } = data;\r\n\t\tconst bvh = new MeshBVH( geometry, { [ SKIP_GENERATION ]: true } );\r\n\t\tbvh._roots = roots;\r\n\r\n\t\tif ( setIndex ) {\r\n\r\n\t\t\tconst indexAttribute = geometry.getIndex();\r\n\t\t\tif ( indexAttribute === null ) {\r\n\r\n\t\t\t\tconst newIndex = new BufferAttribute( data.index, 1, false );\r\n\t\t\t\tgeometry.setIndex( newIndex );\r\n\r\n\t\t\t} else if ( indexAttribute.array !== index ) {\r\n\r\n\t\t\t\tindexAttribute.array.set( index );\r\n\t\t\t\tindexAttribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn bvh;\r\n\r\n\t}\r\n\r\n\tconstructor( geometry, options = {} ) {\r\n\r\n\t\tif ( ! geometry.isBufferGeometry ) {\r\n\r\n\t\t\tthrow new Error( 'MeshBVH: Only BufferGeometries are supported.' );\r\n\r\n\t\t} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {\r\n\r\n\t\t\tthrow new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.' );\r\n\r\n\t\t}\r\n\r\n\t\t// default options\r\n\t\toptions = Object.assign( {\r\n\r\n\t\t\tstrategy: CENTER,\r\n\t\t\tmaxDepth: 40,\r\n\t\t\tmaxLeafTris: 10,\r\n\t\t\tverbose: true,\r\n\r\n\t\t\tsetBoundingBox: true,\r\n\r\n\t\t\t// undocumented options\r\n\r\n\t\t\t// Whether to skip generating the tree. Used for deserialization.\r\n\t\t\t[ SKIP_GENERATION ]: false\r\n\r\n\t\t}, options );\r\n\t\toptions.strategy = Math.max( 0, Math.min( 2, options.strategy ) );\r\n\r\n\t\tthis._roots = null;\r\n\t\tif ( ! options[ SKIP_GENERATION ] ) {\r\n\r\n\t\t\tthis._roots = buildPackedTree( geometry, options );\r\n\r\n\t\t\tif ( ! geometry.boundingBox && options.setBoundingBox ) {\r\n\r\n\t\t\t\tgeometry.boundingBox = this.getBoundingBox( new Box3() );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// retain references to the geometry so we can use them it without having to\r\n\t\t// take a geometry reference in every function.\r\n\t\tthis.geometry = geometry;\r\n\r\n\t}\r\n\r\n\trefit( nodeIndices = null, terminationIndices = null ) {\r\n\r\n\t\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\r\n\r\n\t\t\tnodeIndices = new Set( nodeIndices );\r\n\r\n\t\t}\r\n\r\n\t\tif ( terminationIndices && Array.isArray( terminationIndices ) ) {\r\n\r\n\t\t\tterminationIndices = new Set( terminationIndices );\r\n\r\n\t\t}\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst indexArr = geometry.index.array;\r\n\t\tconst posAttr = geometry.attributes.position;\r\n\t\tconst posArr = posAttr.array;\r\n\r\n\t\t// support for an interleaved position buffer\r\n\t\tconst bufferOffset = posAttr.offset || 0;\r\n\t\tlet stride = 3;\r\n\t\tif ( posAttr.isInterleavedBufferAttribute ) {\r\n\r\n\t\t\tstride = posAttr.data.stride;\r\n\r\n\t\t}\r\n\r\n\t\tlet buffer, uint32Array, uint16Array, float32Array;\r\n\t\tlet byteOffset = 0;\r\n\t\tconst roots = this._roots;\r\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\r\n\r\n\t\t\tbuffer = roots[ i ];\r\n\t\t\tuint32Array = new Uint32Array( buffer );\r\n\t\t\tuint16Array = new Uint16Array( buffer );\r\n\t\t\tfloat32Array = new Float32Array( buffer );\r\n\r\n\t\t\t_traverse( 0, byteOffset );\r\n\t\t\tbyteOffset += buffer.byteLength;\r\n\r\n\t\t}\r\n\r\n\t\tfunction _traverse( node32Index, byteOffset, force = false ) {\r\n\r\n\t\t\tconst node16Index = node32Index * 2;\r\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\r\n\t\t\tif ( isLeaf ) {\r\n\r\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\r\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\r\n\r\n\t\t\t\tlet minx = Infinity;\r\n\t\t\t\tlet miny = Infinity;\r\n\t\t\t\tlet minz = Infinity;\r\n\t\t\t\tlet maxx = - Infinity;\r\n\t\t\t\tlet maxy = - Infinity;\r\n\t\t\t\tlet maxz = - Infinity;\r\n\t\t\t\tfor ( let i = 3 * offset, l = 3 * ( offset + count ); i < l; i ++ ) {\r\n\r\n\t\t\t\t\tconst index = indexArr[ i ] * stride + bufferOffset;\r\n\t\t\t\t\tconst x = posArr[ index + 0 ];\r\n\t\t\t\t\tconst y = posArr[ index + 1 ];\r\n\t\t\t\t\tconst z = posArr[ index + 2 ];\r\n\r\n\t\t\t\t\tif ( x < minx ) minx = x;\r\n\t\t\t\t\tif ( x > maxx ) maxx = x;\r\n\r\n\t\t\t\t\tif ( y < miny ) miny = y;\r\n\t\t\t\t\tif ( y > maxy ) maxy = y;\r\n\r\n\t\t\t\t\tif ( z < minz ) minz = z;\r\n\t\t\t\t\tif ( z > maxz ) maxz = z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (\r\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\r\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\r\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\r\n\r\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\r\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\r\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\r\n\t\t\t\t) {\r\n\r\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\r\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\r\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\r\n\r\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\r\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\r\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\r\n\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconst left = node32Index + 8;\r\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\r\n\r\n\t\t\t\t// the indentifying node indices provided by the shapecast function include offsets of all\r\n\t\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\r\n\t\t\t\tconst offsetLeft = left + byteOffset;\r\n\t\t\t\tconst offsetRight = right + byteOffset;\r\n\r\n\t\t\t\tlet leftChange = false;\r\n\t\t\t\tlet forceLeft = force || terminationIndices && terminationIndices.has( offsetLeft );\r\n\t\t\t\tlet traverseLeft = forceLeft || ( nodeIndices ? nodeIndices.has( offsetLeft ) : true );\r\n\t\t\t\tif ( traverseLeft ) {\r\n\r\n\t\t\t\t\tleftChange = _traverse( left, byteOffset, forceLeft );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet rightChange = false;\r\n\t\t\t\tlet forceRight = force || terminationIndices && terminationIndices.has( offsetRight );\r\n\t\t\t\tlet traverseRight = forceRight || ( nodeIndices ? nodeIndices.has( offsetRight ) : true );\r\n\t\t\t\tif ( traverseRight ) {\r\n\r\n\t\t\t\t\trightChange = _traverse( right, byteOffset, forceRight );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst didChange = leftChange || rightChange;\r\n\r\n\t\t\t\tif ( didChange ) {\r\n\r\n\t\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\t\tconst lefti = left + i;\r\n\t\t\t\t\t\tconst righti = right + i;\r\n\t\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\r\n\t\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\r\n\t\t\t\t\t\tconst minRightValue = float32Array[ righti ];\r\n\t\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\r\n\r\n\t\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\r\n\t\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn didChange;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\ttraverse( callback, rootIndex = 0 ) {\r\n\r\n\t\tconst buffer = this._roots[ rootIndex ];\r\n\t\tconst uint32Array = new Uint32Array( buffer );\r\n\t\tconst uint16Array = new Uint16Array( buffer );\r\n\t\t_traverse( 0 );\r\n\r\n\t\tfunction _traverse( node32Index, depth = 0 ) {\r\n\r\n\t\t\tconst node16Index = node32Index * 2;\r\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\r\n\t\t\tif ( isLeaf ) {\r\n\r\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\r\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\r\n\t\t\t\tcallback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconst left = node32Index + BYTES_PER_NODE / 4;\r\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\r\n\t\t\t\tconst splitAxis = uint32Array[ node32Index + 7 ];\r\n\t\t\t\tconst stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );\r\n\r\n\t\t\t\tif ( ! stopTraversal ) {\r\n\r\n\t\t\t\t\t_traverse( left, depth + 1 );\r\n\t\t\t\t\t_traverse( right, depth + 1 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/* Core Cast Functions */\r\n\traycast( mesh, raycaster, ray, intersects ) {\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst localIntersects = intersects ? [] : null;\r\n\t\tfor ( const root of this._roots ) {\r\n\r\n\t\t\tsetBuffer( root );\r\n\t\t\traycast( 0, mesh, geometry, raycaster, ray, localIntersects );\r\n\t\t\tclearBuffer();\r\n\r\n\t\t}\r\n\r\n\t\tif ( intersects ) {\r\n\r\n\t\t\tfor ( let i = 0, l = localIntersects.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tdelete localIntersects[ i ].localPoint;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tintersects.push( ...localIntersects );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\traycastFirst( mesh, raycaster, ray ) {\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tlet closestResult = null;\r\n\t\tfor ( const root of this._roots ) {\r\n\r\n\t\t\tsetBuffer( root );\r\n\t\t\tconst result = raycastFirst( 0, mesh, geometry, raycaster, ray );\r\n\t\t\tclearBuffer();\r\n\r\n\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\r\n\r\n\t\t\t\tclosestResult = result;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( closestResult ) {\r\n\r\n\t\t\tdelete closestResult.localPoint;\r\n\r\n\t\t}\r\n\r\n\t\treturn closestResult;\r\n\r\n\t}\r\n\r\n\tintersectsGeometry( mesh, otherGeometry, geomToMesh ) {\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tlet result = false;\r\n\t\tfor ( const root of this._roots ) {\r\n\r\n\t\t\tsetBuffer( root );\r\n\t\t\tresult = intersectsGeometry( 0, mesh, geometry, otherGeometry, geomToMesh );\r\n\t\t\tclearBuffer();\r\n\r\n\t\t\tif ( result ) {\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tshapecast( mesh, callbacks, _intersectsTriangleFunc, _orderNodesFunc ) {\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tif ( callbacks instanceof Function ) {\r\n\r\n\t\t\tif ( _intersectsTriangleFunc ) {\r\n\r\n\t\t\t\t// Support the previous function signature that provided three sequential index buffer\r\n\t\t\t\t// indices here.\r\n\t\t\t\tconst originalTriangleFunc = _intersectsTriangleFunc;\r\n\t\t\t\t_intersectsTriangleFunc = ( tri, index, contained, depth ) => {\r\n\r\n\t\t\t\t\tconst i3 = index * 3;\r\n\t\t\t\t\treturn originalTriangleFunc( tri, i3, i3 + 1, i3 + 2, contained, depth );\r\n\r\n\t\t\t\t};\r\n\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcallbacks = {\r\n\r\n\t\t\t\tboundsTraverseOrder: _orderNodesFunc,\r\n\t\t\t\tintersectsBounds: callbacks,\r\n\t\t\t\tintersectsTriangle: _intersectsTriangleFunc,\r\n\t\t\t\tintersectsRange: null,\r\n\r\n\t\t\t};\r\n\r\n\t\t\tconsole.warn( 'MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.' );\r\n\r\n\t\t}\r\n\r\n\t\tlet {\r\n\t\t\tboundsTraverseOrder,\r\n\t\t\tintersectsBounds,\r\n\t\t\tintersectsRange,\r\n\t\t\tintersectsTriangle,\r\n\t\t} = callbacks;\r\n\r\n\t\tif ( intersectsRange && intersectsTriangle ) {\r\n\r\n\t\t\tconst originalIntersectsRange = intersectsRange;\r\n\t\t\tintersectsRange = ( offset, count, contained, depth, nodeIndex ) => {\r\n\r\n\t\t\t\tif ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {\r\n\r\n\t\t\t\t\treturn iterateOverTriangles( offset, count, geometry, intersectsTriangle, contained, depth, triangle );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t};\r\n\r\n\t\t} else if ( ! intersectsRange ) {\r\n\r\n\t\t\tif ( intersectsTriangle ) {\r\n\r\n\t\t\t\tintersectsRange = ( offset, count, contained, depth ) => {\r\n\r\n\t\t\t\t\treturn iterateOverTriangles( offset, count, geometry, intersectsTriangle, contained, depth, triangle );\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tintersectsRange = ( offset, count, contained ) => {\r\n\r\n\t\t\t\t\treturn contained;\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tlet result = false;\r\n\t\tlet byteOffset = 0;\r\n\t\tfor ( const root of this._roots ) {\r\n\r\n\t\t\tsetBuffer( root );\r\n\t\t\tresult = shapecast( 0, geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\r\n\t\t\tclearBuffer();\r\n\r\n\t\t\tif ( result ) {\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbyteOffset += root.byteLength;\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\t/* Derived Cast Functions */\r\n\tintersectsBox( mesh, box, boxToMesh ) {\r\n\r\n\t\tobb.set( box.min, box.max, boxToMesh );\r\n\t\tobb.needsUpdate = true;\r\n\r\n\t\treturn this.shapecast(\r\n\t\t\tmesh,\r\n\t\t\t{\r\n\t\t\t\tintersectsBounds: box => obb.intersectsBox( box ),\r\n\t\t\t\tintersectsTriangle: tri => obb.intersectsTriangle( tri )\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tintersectsSphere( mesh, sphere ) {\r\n\r\n\t\treturn this.shapecast(\r\n\t\t\tmesh,\r\n\t\t\t{\r\n\t\t\t\tintersectsBounds: box => sphere.intersectsBox( box ),\r\n\t\t\t\tintersectsTriangle: tri => tri.intersectsSphere( sphere )\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tclosestPointToGeometry( mesh, otherGeometry, geometryToBvh, target1 = null, target2 = null, minThreshold = 0, maxThreshold = Infinity ) {\r\n\r\n\t\tif ( ! otherGeometry.boundingBox ) {\r\n\r\n\t\t\totherGeometry.computeBoundingBox();\r\n\r\n\t\t}\r\n\r\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\r\n\t\tobb.needsUpdate = true;\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst pos = geometry.attributes.position;\r\n\t\tconst index = geometry.index;\r\n\t\tconst otherPos = otherGeometry.attributes.position;\r\n\t\tconst otherIndex = otherGeometry.index;\r\n\r\n\t\tlet tempTarget1 = null;\r\n\t\tlet tempTarget2 = null;\r\n\t\tif ( target1 ) {\r\n\r\n\t\t\ttempTarget1 = temp1;\r\n\r\n\t\t}\r\n\r\n\t\tif ( target2 ) {\r\n\r\n\t\t\ttempTarget2 = temp2;\r\n\r\n\t\t}\r\n\r\n\t\tlet closestDistance = Infinity;\r\n\t\tobb2.matrix.copy( geometryToBvh ).invert();\r\n\t\tthis.shapecast(\r\n\t\t\tmesh,\r\n\t\t\t{\r\n\r\n\t\t\t\tboundsTraverseOrder: box => {\r\n\r\n\t\t\t\t\treturn obb.distanceToBox( box, Math.min( closestDistance, maxThreshold ) );\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\r\n\r\n\t\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\r\n\r\n\t\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\r\n\t\t\t\t\t\t// save the bounds to use during triangle checks.\r\n\t\t\t\t\t\tif ( isLeaf ) {\r\n\r\n\t\t\t\t\t\t\tobb2.min.copy( box.min );\r\n\t\t\t\t\t\t\tobb2.max.copy( box.max );\r\n\t\t\t\t\t\t\tobb2.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tintersectsRange: ( offset, count ) => {\r\n\r\n\t\t\t\t\tif ( otherGeometry.boundsTree ) {\r\n\r\n\t\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\r\n\t\t\t\t\t\t// the closest bounds in the other geometry to check.\r\n\t\t\t\t\t\treturn otherGeometry.boundsTree.shapecast(\r\n\t\t\t\t\t\t\tnull,\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tboundsTraverseOrder: box => {\r\n\r\n\t\t\t\t\t\t\t\t\treturn obb2.distanceToBox( box, Math.min( closestDistance, maxThreshold ) );\r\n\r\n\t\t\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\r\n\r\n\t\t\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\r\n\r\n\t\t\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\r\n\r\n\t\t\t\t\t\t\t\t\tfor ( let i2 = otherOffset * 3, l2 = ( otherOffset + otherCount ) * 3; i2 < l2; i2 += 3 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\r\n\t\t\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tsetTriangle( triangle, i, index, pos );\r\n\t\t\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\r\n\t\t\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tif ( target1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t\ttarget1.copy( tempTarget1 );\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tif ( target2 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t\ttarget2.copy( tempTarget2 );\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\r\n\t\t\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\r\n\t\t\t\t\t\tconst triCount = otherIndex ? otherIndex.count : otherPos.count;\r\n\t\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 += 3 ) {\r\n\r\n\t\t\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\r\n\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\t\tsetTriangle( triangle, i, index, pos );\r\n\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\r\n\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\r\n\r\n\t\t\t\t\t\t\t\t\tif ( target1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\ttarget1.copy( tempTarget1 );\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tif ( target2 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\ttarget2.copy( tempTarget2 );\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tclosestDistance = dist;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\r\n\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\r\n\r\n\t\t\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t}\r\n\r\n\t\t);\r\n\r\n\t\treturn closestDistance;\r\n\r\n\t}\r\n\r\n\tdistanceToGeometry( mesh, geom, matrix, minThreshold, maxThreshold ) {\r\n\r\n\t\treturn this.closestPointToGeometry( mesh, geom, matrix, null, null, minThreshold, maxThreshold );\r\n\r\n\t}\r\n\r\n\tclosestPointToPoint( mesh, point, target, minThreshold = 0, maxThreshold = Infinity ) {\r\n\r\n\t\t// early out if under minThreshold\r\n\t\t// skip checking if over maxThreshold\r\n\t\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\r\n\t\t// returns Infinity if no value found\r\n\t\tconst minThresholdSq = minThreshold * minThreshold;\r\n\t\tconst maxThresholdSq = maxThreshold * maxThreshold;\r\n\t\tlet closestDistanceSq = Infinity;\r\n\t\tthis.shapecast(\r\n\r\n\t\t\tmesh,\r\n\t\t\t{\r\n\r\n\t\t\t\tboundsTraverseOrder: box => {\r\n\r\n\t\t\t\t\ttemp.copy( point ).clamp( box.min, box.max );\r\n\t\t\t\t\treturn temp.distanceToSquared( point );\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\r\n\r\n\t\t\t\t\treturn score < closestDistanceSq && score < maxThresholdSq;\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tintersectsTriangle: tri => {\r\n\r\n\t\t\t\t\ttri.closestPointToPoint( point, temp );\r\n\t\t\t\t\tconst distSq = point.distanceToSquared( temp );\r\n\t\t\t\t\tif ( distSq < closestDistanceSq ) {\r\n\r\n\t\t\t\t\t\tif ( target ) {\r\n\r\n\t\t\t\t\t\t\ttarget.copy( temp );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tclosestDistanceSq = distSq;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( distSq < minThresholdSq ) {\r\n\r\n\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t}\r\n\r\n\t\t);\r\n\r\n\t\treturn Math.sqrt( closestDistanceSq );\r\n\r\n\t}\r\n\r\n\tdistanceToPoint( mesh, point, minThreshold, maxThreshold ) {\r\n\r\n\t\treturn this.closestPointToPoint( mesh, point, null, minThreshold, maxThreshold );\r\n\r\n\t}\r\n\r\n\tgetBoundingBox( target ) {\r\n\r\n\t\ttarget.makeEmpty();\r\n\r\n\t\tconst roots = this._roots;\r\n\t\troots.forEach( buffer => {\r\n\r\n\t\t\tarrayToBox( 0, new Float32Array( buffer ), tempBox );\r\n\t\t\ttarget.union( tempBox );\r\n\r\n\t\t} );\r\n\r\n\t\treturn target;\r\n\r\n\t}\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"module"}